# Building Scalable Distributed Systems
## Building the server

### Major classes' relationships
![Relationships](https://github.com/thisIsGloriaWu/DistributedSystem/blob/main/6650_a2_backend/src/main/java/A2_relationship.png)

- I implemented `RemoteQueue` and `ConsumerMain` to establish `Producer/Consumer` model between servers, RabbitMQ and consumers.

- When the client requests doPost(), **load balancer** gets requests and distributes to multiple backend servlets. Servlets will send messages to a remote queue generated by **RabbitMQ**, then `ConsumerMain` retrieves and handles messages from the remote queue.


### Major classes design

- `RemoteQueue` in package `rabbitmq`: 

  - Connects to RabbitMQ and generates a channel pool implemented by `BlockingQueue` when initialized.
  - `postMessage()` method: let servers pass parameters `skierId` and `LiftRide` and post them to remote queue. When posting messages, the server takes a channel from pool and returns it to pool after finishing tasks.
  - `handleMessages()` method: register callback for consuming messages in RMQ.


- `SkiersApiController` in package `io.swagger.api`:

  - In `writeNewLiftRide` method, validates the URL and JSON payload, then uses `postMessage()` to send messages.


- `ConsumerMain` in package `consumer`:

  - map is implemented as `ConcurrentMap` to ensure **thread safety**.
  - uses `handleMessages()` to consume messages.
  - utilizes `basicConsume()`("Push API") instead of "Pull API" in `handleMessages()`. 
  - According to RabbitMQ official documentations, "Pull API" is ineffectively polling and applications repeatedly have to ask for results even if the vast majority of the requests yield no results. ([Pull API documentation](https://www.rabbitmq.com/api-guide.html#getting))
  - However, Push API used in my design will deliver messages automatically as they arrived. ([Push API documentation](https://www.rabbitmq.com/api-guide.html#consuming), [Pull vs Push](https://www.cloudamqp.com/blog/rabbitmq-basic-consume-vs-rabbitmq-basic-get.html))


### Test Results
single instance test result:

![single](https://github.com/thisIsGloriaWu/DistributedSystem/blob/main/6650_a2_backend/test%20results/single-2.png)

load balanced test result:

![balanced](https://github.com/thisIsGloriaWu/DistributedSystem/blob/main/6650_a2_backend/test%20results/balanced-1.png)

RMQ management window:

![RMQ](https://github.com/thisIsGloriaWu/DistributedSystem/blob/main/6650_a2_backend/test%20results/rabbitmq-web-ui.png)

- The first two curves are single instances' results.
- The last two curves are load balanced instances' results.
- The bottleneck of the system is at **servlets**. As you can see, there's hardly a message in the queue as they are all immediately consumed.
- This is not the full potential of the system as I only use 3 servlets.
